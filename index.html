<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Megabonk ‚Äî Full Version</title>
<style>
  :root{--bg:#070810;--fg:#4efc8c;--accent:#ff5d7a}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,ui-sans-serif,system-ui,monospace}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(#02030b,#000000)}
  #ui{position:fixed;z-index:50;left:12px;top:10px;color:var(--fg);font:15px monospace}
  #ui div{margin-bottom:6px}
  button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:10px;font:14px monospace}
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:60;color:var(--fg)}
  .panel{background:rgba(0,0,0,0.9);border:2px solid rgba(78,252,140,0.06);padding:18px;border-radius:12px;text-align:center;min-width:320px}
  .shop-btn{display:block;margin:8px auto;padding:10px 14px;width:100%;max-width:420px}
  #achRoot{position:fixed;left:50%;transform:translateX(-50%);bottom:26px;z-index:80;pointer-events:none}
  .ach{background:#00120a;padding:10px 14px;border-radius:10px;border:1px solid rgba(78,252,140,0.12);color:var(--fg);margin-top:8px;opacity:0;animation:achIn 0.32s forwards}
  @keyframes achIn{to{opacity:1;transform:translateY(-6px)}}
  /* Mobile controls */
  #touchLeft,#touchRight,#touchJump,#touchShoot{position:fixed;z-index:45;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.03);border-radius:50%;width:78px;height:78px;display:flex;align-items:center;justify-content:center;color:var(--fg);backdrop-filter: blur(6px)}
  #touchLeft{left:18px;bottom:18px}
  #touchRight{left:110px;bottom:18px}
  #touchJump{right:110px;bottom:18px}
  #touchShoot{right:18px;bottom:18px}
  /* small screens */
  @media(max-width:560px){
    #touchLeft,#touchRight,#touchJump,#touchShoot{width:64px;height:64px}
    .panel{min-width:260px}
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div>Wave: <span id="wave">1</span> | Score: <span id="score">0</span> (x<span id="combo">1</span>)</div>
  <div>Health: <span id="health">100</span>% | Gold: $<span id="gold">0</span></div>
  <div><button onclick="openShop()">SHOP</button> <button onclick="togglePause()">PAUSE</button></div>
</div>

<div id="waveComplete" class="overlay">
  <div class="panel">
    <h2>WAVE <span id="wcWave">1</span> TAMAMLANDI!</h2>
    <p>Bonus Gold: +$<span id="bonusGold">0</span></p>
    <div style="margin-top:12px">
      <button class="shop-btn" onclick="openShop()">Kalƒ±cƒ± Shop A√ß</button>
      <button class="shop-btn" onclick="nextWave()">Sonraki Wave</button>
    </div>
  </div>
</div>

<div id="shop" class="overlay">
  <div class="panel">
    <h2>üõí KALICI UPGRADE (Her run‚Äôda kalƒ±r)</h2>
    <div>
      <button class="shop-btn" onclick="buyPermanent(0)">Hasar +20% ($<span id="cost0">50</span>)</button>
      <button class="shop-btn" onclick="buyPermanent(1)">Max Can +20 ($<span id="cost1">80</span>)</button>
      <button class="shop-btn" onclick="buyPermanent(2)">Hƒ±z +2 ($<span id="cost2">100</span>)</button>
      <button class="shop-btn" onclick="buyPermanent(3)">Yeni Silah (Lazer) ($<span id="cost3">150</span>)</button>
    </div>
    <div style="margin-top:12px"><button onclick="closeShop()">Kapat</button></div>
  </div>
</div>

<div id="gameOver" class="overlay">
  <div class="panel">
    <h1>GAME OVER</h1>
    <p>Biten Wave: <span id="finalWave">1</span></p>
    <p>Bu run Gold: <span id="runGold">0</span></p>
    <p>En ƒ∞yi Wave: <span id="bestWave">1</span></p>
    <div style="margin-top:12px"><button onclick="restartRun()">YENƒ∞DEN BA≈ûLA</button></div>
  </div>
</div>

<div id="achRoot"></div>

<!-- Mobile Controls -->
<div id="touchLeft">‚óÄ</div>
<div id="touchRight">‚ñ∂</div>
<div id="touchJump">‚ñ≤</div>
<div id="touchShoot">‚óè</div>

<script>
/* =====================
   FULL GAME: Megabonk Mobile ‚Äî Full version
   ===================== */

/* ---------- canvas setup ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

/* ---------- Persistent data ---------- */
const SAVE_KEY = 'megabonk_permanent_v2';
const ACH_KEY = 'megabonk_ach_v2';
let permanent = {
  damageMult: 1,
  maxHealth: 100,
  speedBonus: 0,
  hasLazer: false,
  bestWave: 1,
  goldBank: 0
};
function loadPermanent(){ try{ const s=localStorage.getItem(SAVE_KEY); if(s) permanent=JSON.parse(s);}catch(e){}}
function savePermanent(){ localStorage.setItem(SAVE_KEY, JSON.stringify(permanent)); }
loadPermanent();

/* ---------- Achievements ---------- */
let achievements = {
  firstKill:false, wave5:false, rich100:false, bossSlain:false, flawless:false
};
function loadAchievements(){ try{ const s=localStorage.getItem(ACH_KEY); if(s) achievements=JSON.parse(s);}catch(e){}}
function saveAchievements(){ localStorage.setItem(ACH_KEY, JSON.stringify(achievements)); }
loadAchievements();

function showAchievement(text){
  const root = document.getElementById('achRoot');
  const el = document.createElement('div'); el.className='ach'; el.textContent = 'üèÜ ' + text;
  root.appendChild(el);
  setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(8px)'; setTimeout(()=>el.remove(),420); }, 2800);
}
function unlock(id, text){
  if(!achievements[id]){ achievements[id]=true; saveAchievements(); showAchievement(text); }
}

/* ---------- Game variables ---------- */
const TILE = 64;            // tile size (pixels)
let level = [];             // tile map array of strings
let worldWidth = 0, worldHeight = 0;
let cameraX = 0, shake = 0;
let score=0, combo=1, gold=0, wave=1;
let enemies = [], projectiles = [], particles = [], gems = [];
let paused=false, inShop=false, running=true;
let enemiesToSpawn=0, enemiesSpawned=0;
let xp=0;

/* ---------- Player / Sprite ---------- */
let playerSprite = new Image();
playerSprite.src = "https://i.imgur.com/6X12K9G.png"; // replace with your sprite sheet (4 frames)
playerSprite.onload = ()=>{/* ok */}
let animFrame = 0, animTimer = 0;

let player = {
  x: 220,
  y: 0,
  vx:0, vy:0,
  size:36,
  onGround:false,
  speed: 6 + permanent.speedBonus,
  health: permanent.maxHealth,
  facing:1,
  attacking:false,
  attackTimer:0,
  spriteReady: true
};

/* ---------- Weapons ---------- */
let weapons = [{name:'Bonk', dmg:25, rate:12, cooldown:0}];
if(permanent.hasLazer) weapons.push({name:'Lazer',dmg:18,rate:7,cooldown:0});

/* ---------- Level generation ---------- */
function generateLevel(cols=80, rows=12){
  level = [];
  for(let y=0;y<rows;y++){
    let row = '';
    for(let x=0;x<cols;x++){
      if(y===rows-1) row+='1'; // ground
      else {
        // more deterministic platforming near start, increasing random later
        if(x<6){
          row += (Math.random() < 0.25 && y>5) ? '1' : '0';
        } else {
          if(Math.random() < 0.06 && y>4) row+='1';
          else if(Math.random() < 0.02 && y>4) row+='2';
          else row+='0';
        }
      }
    }
    level.push(row);
  }
  worldWidth = cols * TILE; worldHeight = rows * TILE;
}

/* ---------- Utility ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(a,b){ return a + Math.random()*(b-a); }
function now(){ return performance.now(); }

/* ---------- Input: keyboard + touch ---------- */
let keys = {};
addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key===' '){ e.preventDefault(); }});
addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

/* Touch buttons */
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');
const touchJump = document.getElementById('touchJump');
const touchShoot = document.getElementById('touchShoot');

let touchState = {left:false,right:false,jump:false,shoot:false};

['touchstart','mousedown'].forEach(evt=>{
  touchLeft.addEventListener(evt, e=>{ touchState.left=true; e.preventDefault(); });
  touchRight.addEventListener(evt, e=>{ touchState.right=true; e.preventDefault(); });
  touchJump.addEventListener(evt, e=>{ touchState.jump=true; e.preventDefault(); });
  touchShoot.addEventListener(evt, e=>{ touchState.shoot=true; e.preventDefault(); });
});
['touchend','mouseup','touchcancel','mouseleave'].forEach(evt=>{
  touchLeft.addEventListener(evt, e=>{ touchState.left=false; e.preventDefault(); });
  touchRight.addEventListener(evt, e=>{ touchState.right=false; e.preventDefault(); });
  touchJump.addEventListener(evt, e=>{ touchState.jump=false; e.preventDefault(); });
  touchShoot.addEventListener(evt, e=>{ touchState.shoot=false; e.preventDefault(); });
});

/* Canvas touch for jump/shoot */
canvas.addEventListener('touchstart', e=>{
  const t = e.touches[0]; if(t.clientX > W/2) touchState.shoot=true; else touchState.jump=true;
});

/* ---------- Collision helpers ---------- */
function tileAt(px,py){
  const cx = Math.floor(px / TILE);
  const cy = Math.floor(py / TILE);
  if(cy < 0 || cy >= level.length || cx < 0 || cx >= level[0].length) return '0';
  return level[cy][cx];
}
function rectIntersects(rx,ry,rw,rh, sx,sy,sw,sh){
  return !(sx > rx+rw || sx+sw < rx || sy > ry+rh || sy+sh < ry);
}

/* ---------- Spawn / Enemies ---------- */
function spawnEnemy(type=0, x=null){
  const hpBase = 35 + wave*8;
  const startX = (x!==null) ? x : player.x + rand(600, 1100);
  let size=28, hp=hpBase;
  let vx = - (1.0 + rand(0.2, 0.9)) * (1 + wave*0.04);
  if(type===1){ vx *= 1.6; hp *= 0.8; size=20; }
  if(type===2){ hp *= 2.2; size=36; vx *= 0.6; }
  if(type===3){ size=24; } // shooter
  // elite
  const elite = Math.random() < 0.08;
  if(elite){ hp *= 3; size *= 1.4; }
  enemies.push({x:startX, y:H - 175 - Math.random()*120, vx, size, health:hp, type, elite, shootTimer:0, dead:false});
}

/* ---------- Projectiles ---------- */
function fireProjectile(x,y,vx,vy,dmg,life=120,color='#ffea00',owner='player'){
  projectiles.push({x,y,vx,vy,dmg,life,color,owner});
}

/* ---------- Gem spawn ---------- */
function spawnGem(x,y){
  gems.push({x,y,size:10,life:180});
}

/* ---------- Particles ---------- */
function createParticles(x,y,color,size=4,count=18){
  for(let i=0;i<count;i++){
    particles.push({x,y,vx:rand(-6,6),vy:rand(-8,2),life:rand(30,60),size:rand(2,size),color});
  }
}

/* ---------- Wave / progression ---------- */
function startNewWave(){
  enemies = []; projectiles=[]; particles=[]; gems=[];
  enemiesSpawned = 0;
  enemiesToSpawn = 6 + wave*4 + (wave%5===0 ? 6 : 0);
  document.getElementById('wave').textContent = wave;
  xp = 0;
  // regen player into start region
  player.x = 200; player.y = 0; player.vy=0; player.health = permanent.maxHealth;
  generateLevel(80, 12);
  // place a few early enemies
  for(let i=0;i<3;i++) spawnEnemy(Math.random()<0.25?1:0, player.x + rand(600,1200));
}

function waveComplete(){
  paused=true;
  const bonus = Math.floor(40 + wave*35 + combo*2);
  gold += bonus;
  permanent.goldBank += Math.floor(bonus*0.6);
  savePermanent();
  document.getElementById('wcWave').textContent = wave;
  document.getElementById('bonusGold').textContent = bonus;
  document.getElementById('waveComplete').style.display = 'flex';
}

/* ---------- Shop ---------- */
function openShop(){
  paused = true; inShop=true;
  document.getElementById('waveComplete').style.display = 'none';
  document.getElementById('shop').style.display = 'flex';
  document.getElementById('cost0').textContent = Math.floor(50 + wave*8);
  document.getElementById('cost1').textContent = Math.floor(80 + wave*10);
  document.getElementById('cost2').textContent = Math.floor(100 + wave*12);
  document.getElementById('cost3').textContent = Math.floor(150 + wave*15);
}
function closeShop(){ document.getElementById('shop').style.display='none'; inShop=false; nextWave(); }
function buyPermanent(i){
  const costs = [50+wave*8,80+wave*10,100+wave*12,150+wave*15];
  if(gold < costs[i]){ alert("Yeterli altƒ±n yok!"); return; }
  gold -= costs[i];
  if(i===0) permanent.damageMult += 0.2;
  if(i===1){ permanent.maxHealth += 20; player.health = permanent.maxHealth; }
  if(i===2) permanent.speedBonus += 1.5;
  if(i===3 && !permanent.hasLazer){ permanent.hasLazer=true; weapons.push({name:'Lazer',dmg:18,rate:7,cooldown:0}); }
  savePermanent();
  alert("Kalƒ±cƒ± upgrade alƒ±ndƒ±! üéâ");
}

/* ---------- Game over / restart ---------- */
function gameOver(){
  paused = true;
  running = false;
  if(wave > permanent.bestWave) permanent.bestWave = wave;
  savePermanent();
  document.getElementById('finalWave').textContent = wave;
  document.getElementById('runGold').textContent = gold;
  document.getElementById('bestWave').textContent = permanent.bestWave;
  document.getElementById('gameOver').style.display = 'flex';
  if(!achievements.bossSlain && enemies.some(e=>e.type===99 && e.dead)) unlock('bossSlain','Boss defeated!');
}
function restartRun(){
  // bank permanent gold
  permanent.goldBank += Math.floor(gold*0.5);
  savePermanent();
  document.getElementById('gameOver').style.display = 'none';
  running=true;
  wave=1; score=0; combo=1; gold=0;
  weapons = [{name:'Bonk', dmg:25, rate:12, cooldown:0}];
  if(permanent.hasLazer) weapons.push({name:'Lazer',dmg:18,rate:7,cooldown:0});
  player.health = permanent.maxHealth;
  startNewWave();
  paused=false;
}

/* ---------- Helper UI controls ---------- */
function togglePause(){ paused = !paused; if(paused) document.getElementById('waveComplete').style.display='none'; }
function nextWave(){ document.getElementById('waveComplete').style.display='none'; paused=false; wave++; startNewWave(); }

/* ---------- Spawn boss ---------- */
function spawnBoss(){
  enemies.push({x: player.x + 900, y: H-200, vx:-0.6, size:120, health: 1200 + wave*240, type:99, elite:false, dead:false, phase:0});
  createParticles(player.x+900, H-200, '#ff77ff', 8, 30);
}

/* ---------- Main loop ---------- */
function gameLoop(){
  if(!running) return;
  requestAnimationFrame(gameLoop);
  if(paused || inShop){ drawUIOnly(); return; }

  // core updates
  updatePlayer();
  spawnLogic();
  updateEnemies();
  updateProjectiles();
  updateGems();
  updateParticles();

  // render
  renderScene();

  // UI text
  document.getElementById('score').textContent = Math.floor(score);
  document.getElementById('combo').textContent = combo.toFixed(1);
  document.getElementById('health').textContent = Math.max(0, Math.floor(player.health));
  document.getElementById('gold').textContent = gold;
  document.getElementById('wave').textContent = wave;

  // checks
  if(player.health <= 0){ gameOver(); }
  combo = Math.max(1, combo - 0.002);
}

/* ---------- Update functions ---------- */
function updatePlayer(){
  // inputs
  let move = 0;
  if(keys['a']||keys['arrowleft']||touchState.left) move -= 1;
  if(keys['d']||keys['arrowright']||touchState.right) move += 1;
  player.vx = move * (player.speed + permanent.speedBonus);

  // jump
  if((keys['w']||keys['arrowup']||keys[' ']||touchState.jump) && player.onGround){
    player.vy = -18; player.onGround=false;
  }

  // apply gravity
  player.vy += 0.9;
  player.x += player.vx;
  player.y += player.vy;

  // basic world bounds
  player.x = clamp(player.x, 20, worldWidth - 20);

  // collisions with tiles (simple AABB)
  player.onGround = false;
  const pxL = player.x - player.size/2;
  const pxT = player.y - player.size/2;
  const pw = player.size;
  const ph = player.size;

  // check surrounding tiles only for efficiency
  const minCol = Math.max(0, Math.floor((pxL - TILE) / TILE));
  const maxCol = Math.min(level[0].length-1, Math.floor((pxL + pw + TILE) / TILE));
  const minRow = Math.max(0, Math.floor((pxT - TILE) / TILE));
  const maxRow = Math.min(level.length-1, Math.floor((pxT + ph + TILE) / TILE));

  for(let ry=minRow; ry<=maxRow; ry++){
    const row = level[ry];
    for(let cx=minCol; cx<=maxCol; cx++){
      const tile = row[cx];
      if(tile==='0') continue;
      const tx = cx * TILE, ty = ry * TILE;
      if(rectIntersects(pxL,pxT,pw,ph, tx,ty,TILE,TILE)){
        // simple collision resolution: push player up if moving down
        if(player.vy > 0 && (pxT + ph) - ty < 32){
          player.y = ty - ph/2;
          player.vy = 0;
          player.onGround = true;
        } else if(player.vy < 0 && ty + TILE - pxT < 24){
          player.y = ty + TILE + ph/2 + 1;
          player.vy = 0.5;
        } else {
          // horizontal push
          if(player.vx > 0) player.x = tx - pw/2 - 1;
          else if(player.vx < 0) player.x = tx + TILE + pw/2 + 1;
        }
      }
    }
  }

  // Camera follow
  cameraX = player.x - W/2;
  cameraX = clamp(cameraX, 0, Math.max(0, worldWidth - W));

  // attack auto-fire (we'll auto-target)
  weapons.forEach(w=>{
    if(w.cooldown > 0) w.cooldown--;
    else {
      if(Math.random() < 0.5 || touchState.shoot || keys['k']){ // semi-auto
        // pick nearest enemy
        let target = null, md=Infinity;
        enemies.forEach(en=>{
          const d = Math.hypot(en.x - player.x, en.y - player.y);
          if(d < md){ md = d; target = en; }
        });
        if(target){
          w.cooldown = w.rate;
          const dx = target.x - player.x;
          const dy = target.y - (player.y - 10);
          const dist = Math.hypot(dx,dy) || 1;
          const speed = 14;
          fireProjectile(player.x, player.y - 10, dx/dist*speed, dy/dist*speed, Math.round(w.dmg * permanent.damageMult), 80, '#ffee33','player');
        } else {
          // no enemies, small forward shot
          fireProjectile(player.x, player.y - 10, 12 * player.facing, 0, Math.round(w.dmg * permanent.damageMult), 60, '#ffee33','player');
          w.cooldown = w.rate + 8;
        }
      }
    }
  });

  // slow-motion effect when attackTimer active
  if(player.attackTimer>0) player.attackTimer--;
}

/* ---------- Spawn logic ---------- */
let spawnTicker = 0;
function spawnLogic(){
  // spawn enemies until target reached
  spawnTicker++;
  if(enemiesSpawned < enemiesToSpawn && Math.random() < 0.04 + wave*0.002){
    const t = Math.random() < 0.25 ? 1 : Math.random() < 0.6 ? 0 : Math.random()<0.85?3:2;
    spawnEnemy(t); enemiesSpawned++;
  }
  // occasionally spawn gems from map holes
  if(Math.random() < 0.002) spawnGem(player.x + rand(400,1000), H - rand(120,200));

  // boss spawn on wave%5
  if(enemiesToSpawn>0 && wave%5===0 && enemiesSpawned >= enemiesToSpawn && !enemies.some(e=>e.type===99)){
    spawnBoss();
  }
}

/* ---------- Enemies update ---------- */
function updateEnemies(){
  for(let i=enemies.length-1;i>=0;i--){
    const en = enemies[i];
    // basic AI
    if(en.type === 0){ // walker
      en.x += en.vx;
      en.y += Math.sin((now()+i*100)/700) * 0.6;
    } else if(en.type === 1){ // fast
      en.x += en.vx * 1.4;
    } else if(en.type === 2){ // tank
      en.x += en.vx * 0.6;
    } else if(en.type === 3){ // shooter
      en.x += en.vx * 0.5;
      en.shootTimer++;
      if(en.shootTimer > 80){
        en.shootTimer = 0;
        const dx = player.x - en.x;
        const dy = player.y - en.y;
        fireProjectile(en.x, en.y, dx/40, dy/40, 12, 120, '#ff44ff','enemy');
      }
    } else if(en.type === 99){ // boss
      // phase AI
      en.phase = en.phase || 0;
      en.phaseTimer = (en.phaseTimer||0)+1;
      if(en.phase === 0){
        // move slowly left
        if(en.x > player.x + 450) en.x += en.vx;
        else { en.phase = 1; en.phaseTimer=0; }
      } else if(en.phase === 1){
        // shoot spread
        if(en.phaseTimer % 30 === 0){
          for(let a=-1;a<=1;a++){
            const ang = (Math.atan2(player.y - en.y, player.x - en.x) + a*0.2);
            fireProjectile(en.x, en.y, Math.cos(ang)*6, Math.sin(ang)*6, 18, 160, '#ff88ff','enemy');
          }
        }
        if(en.phaseTimer > 300){ en.phase = 0; en.phaseTimer=0; }
      }
    }

    // collide with player
    if(Math.hypot(en.x - player.x, en.y - player.y) < en.size + player.size*0.6){
      player.health -= (en.type===2?2.8:1.6);
      shake = 10;
      createParticles(en.x, en.y, '#ff4444', 6, 14);
    }

    // check projectile hits
    for(let j=projectiles.length-1;j>=0;j--){
      const p = projectiles[j];
      if(p.owner === 'player' && Math.hypot(p.x - en.x, p.y - en.y) < en.size + 6){
        en.health -= p.dmg;
        projectiles.splice(j,1);
        createParticles(en.x, en.y, '#ffee33', 6, 12);
        if(en.health <= 0 && !en.dead){
          en.dead = true;
          // death
          score += 30 * combo;
          gold += 3;
          combo = Math.min(12, combo + 0.45);
          spawnGem(en.x, en.y - 6);
          createParticles(en.x, en.y, '#ffcc00', 6, 30);
          // drop extra on elite
          if(en.elite){ gold += 8; score += 200; createParticles(en.x, en.y, '#ff88ff', 8, 24); }
          // remove after animation
          setTimeout(()=>{ const idx = enemies.indexOf(en); if(idx>=0) enemies.splice(idx,1); }, 80);
          // achievement
          if(!achievements.firstKill) unlock('firstKill','First Kill! üéâ');
          if(en.type === 99){
            unlock('bossSlain','Boss Slain!');
            wave += 1; setTimeout(()=>waveComplete(), 450);
          }
        }
        break;
      }
    }

    // remove if well left of camera
    if(en.x < cameraX - 200) enemies.splice(i,1);
  }

  // spawn routine: if enemies cleared and spawned reached, waveComplete
  if(enemies.length === 0 && enemiesSpawned >= enemiesToSpawn && !paused){
    waveComplete();
  }
}

/* ---------- Projectiles update ---------- */
function updateProjectiles(){
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    // collision with player if from enemy
    if(p.owner === 'enemy' && Math.hypot(p.x - player.x, p.y - player.y) < player.size/1.6){
      player.health -= p.dmg;
      createParticles(player.x, player.y, '#ff3366', 8, 22);
      shake = 12; projectiles.splice(i,1); continue;
    }
    // collisions with solid tiles (destroy)
    const tile = tileAt(p.x, p.y);
    if(tile !== '0'){ createParticles(p.x, p.y, '#ffaa33', 6, 10); projectiles.splice(i,1); continue; }
    if(p.life <= 0) projectiles.splice(i,1);
  }
}

/* ---------- Gems update ---------- */
function updateGems(){
  for(let i=gems.length-1;i>=0;i--){
    const g = gems[i];
    g.x += (player.x - g.x) * 0.08;
    g.y += (player.y - g.y) * 0.08;
    g.life--;
    if(Math.hypot(g.x - player.x, g.y - player.y) < 36){
      gold += 6; score += 20; createParticles(g.x, g.y, '#00ffee', 4, 12); gems.splice(i,1);
      if(gold >= 100 && !achievements.rich100) unlock('rich100','100 Gold Collected!');
    }
    if(g.life <= 0) gems.splice(i,1);
  }
}

/* ---------- Particles update ---------- */
function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.34; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
}

/* ---------- Rendering ---------- */
function drawUIOnly(){
  // lightweight draw when paused or in shop: draw background minimal
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);
}

function renderScene(){
  // background
  ctx.clearRect(0,0,W,H);
  // parallax sky
  ctx.fillStyle = '#031019';
  ctx.fillRect(0,0,W,H);
  for(let i=0;i<40;i++){
    const bx = (i*320 - cameraX*0.15) % (W+400) - 200;
    ctx.fillStyle = 'rgba(0,200,255,0.03)';
    ctx.fillRect(bx, 80 + Math.sin(i*0.6 + now()/800)*30, 220, 420);
  }

  // fog gradient (whole-screen)
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'rgba(0,0,0,0)');
  g.addColorStop(1,'rgba(0,0,0,0.6)');
  // world transform (camera)
  ctx.save();
  ctx.translate( -cameraX + (Math.random()*shake - shake/2), Math.random()*shake*0.02 );

  // tilemap draw
  level.forEach((row, ry)=>{
    for(let cx=0; cx<row.length; cx++){
      const t = row[cx];
      if(t==='0') continue;
      const tx = cx * TILE;
      const ty = ry * TILE;
      // ground tile
      if(t==='1'){
        // tile body
        ctx.fillStyle = '#121212';
        ctx.fillRect(tx, ty, TILE, TILE);
        // top surface
        ctx.fillStyle = '#1f8f5b';
        ctx.fillRect(tx+6, ty+6, TILE-12, TILE/3);
        // shadow
        ctx.fillStyle = 'rgba(0,0,0,0.18)';
        ctx.fillRect(tx, ty+TILE-10, TILE, 8);
      } else if(t==='2'){
        // obstacle
        ctx.fillStyle = '#6b1a1a';
        ctx.fillRect(tx, ty, TILE, TILE);
        ctx.fillStyle = '#ab4a4a';
        ctx.fillRect(tx+8, ty+8, TILE-16, TILE-16);
      }
    }
  });

  // gems
  gems.forEach(gem=>{
    ctx.beginPath();
    ctx.fillStyle = '#0ff';
    ctx.arc(gem.x, gem.y, gem.size, 0, Math.PI*2);
    ctx.fill();
    ctx.closePath();
  });

  // enemies
  enemies.forEach(en=>{
    ctx.save();
    ctx.shadowColor = en.elite ? '#ffec77' : '#000';
    ctx.shadowBlur = en.elite ? 28 : 12;
    ctx.fillStyle = en.type===3 ? '#f0a' : en.type===2 ? '#f80' : en.type===1 ? '#0ff' : '#ff3';
    if(en.type===99){ ctx.fillStyle='#ff66ff'; ctx.shadowBlur=40; }
    ctx.beginPath();
    ctx.arc(en.x, en.y, en.size, 0, Math.PI*2);
    ctx.fill();
    ctx.closePath();
    ctx.restore();
    // health bar
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(en.x - 36, en.y - en.size - 14, 72, 8);
    ctx.fillStyle = '#33ff88';
    const hs = clamp(en.health / (1200 + wave*240), 0, 1);
    ctx.fillRect(en.x - 36, en.y - en.size - 14, 72 * (en.type===99 ? clamp(en.health/(1200+wave*240):1,0,1) : clamp(en.health/(1000+wave*100),0,1)), 8);
  });

  // projectiles
  projectiles.forEach(p=>{
    ctx.save();
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 20;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x-4, p.y-4, 8, 8);
    ctx.restore();
  });

  // particles
  particles.forEach(p=>{
    ctx.globalAlpha = clamp(p.life/60, 0, 1);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size);
    ctx.globalAlpha = 1;
  });

  // player draw (sprite or fallback)
  ctx.save();
  ctx.shadowColor = '#00ff88';
  ctx.shadowBlur = 24;
  if(playerSprite.complete && playerSprite.naturalWidth > 0){
    animTimer++;
    if(animTimer > 6){ animFrame = (animFrame + 1) % 4; animTimer = 0; }
    const sw = 64, sh = 64;
    const dw = 72, dh = 72;
    ctx.translate(player.x, player.y - 10);
    ctx.scale(player.facing, 1);
    ctx.drawImage(playerSprite, animFrame * sw, 0, sw, sh, -dw/2, -dh/2, dw, dh);
  } else {
    // fallback simple body
    ctx.fillStyle = '#0ff';
    ctx.beginPath();
    ctx.arc(player.x, player.y - 12, player.size*0.9, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#003322';
    ctx.fillRect(player.x - 12, player.y + 10, 24, 10);
  }
  ctx.restore();

  // draw HUD world-space shadows, then restore
  ctx.fillStyle = g;
  ctx.fillRect(cameraX, 0, W, H);

  ctx.restore(); // restore camera

  // global overlay effects
  if(shake > 0) shake *= 0.92;
}

/* ---------- Start ---------- */
generateLevel();
startNewWave();
gameLoop();

/* ---------- Initial Save/Load housekeeping ---------- */
function initUIFromSave(){
  // show saved best wave
  document.getElementById('bestWave').textContent = permanent.bestWave;
}
initUIFromSave();

/* ---------- Misc helpers ---------- */
function spawnRandomObstacleAhead(){
  const px = Math.floor((player.x + rand(400,900))/TILE);
  const py = level.length - 2;
  if(level[py][px] === '0'){
    const row = level[py].split(''); row[px] = '2'; level[py] = row.join('');
  }
}

/* ---------- Expose some functions to console for debug ---------- */
window.startNewWave = startNewWave;
window.nextWave = nextWave;
window.openShop = openShop;
window.closeShop = closeShop;
window.buyPermanent = buyPermanent;
window.restartRun = restartRun;
window.togglePause = togglePause;

/* ---------- Save achievements periodically ---------- */
setInterval(()=>{ savePermanent(); saveAchievements(); }, 5000);

</script>
</body>
</html>